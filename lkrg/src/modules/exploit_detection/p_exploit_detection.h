/*
 * pi3's Linux kernel Runtime Guard
 *
 * Component:
 *  - Exploit detection main module
 *
 * Notes:
 *  - None
 *
 * Timeline:
 *  - Created: 06.IX.2017
 *
 * Author:
 *  - Adam 'pi3' Zabrocki (http://pi3.com.pl)
 *
 */

#ifndef P_EXPLOIT_DETECTION_MAIN_H
#define P_EXPLOIT_DETECTION_MAIN_H

#define P_ED_PROCESS_OFF_MAX 0x1000

#define p_ed_alloc_valid()      kmem_cache_alloc(p_ed_wq_valid_cache, GFP_ATOMIC)
#define p_ed_free_valid(name)   kmem_cache_free(p_ed_wq_valid_cache, (void *)(name))


struct p_cred {

    kuid_t uid;                      /* real UID of the task */
    kgid_t gid;                      /* real GID of the task */
    kuid_t suid;                     /* saved UID of the task */
    kgid_t sgid;                     /* saved GID of the task */
    kuid_t euid;                     /* effective UID of the task */
    kgid_t egid;                     /* effective GID of the task */
    kuid_t fsuid;                    /* UID for VFS ops */
    kgid_t fsgid;                    /* GID for VFS ops */
    unsigned securebits;             /* SUID-less security management */
    kernel_cap_t cap_inheritable;    /* caps our children can inherit */
    kernel_cap_t cap_permitted;      /* caps we're permitted */
    kernel_cap_t cap_effective;      /* caps we can actually use */
    kernel_cap_t cap_bset;           /* capability bounding set */
    kernel_cap_t cap_ambient;        /* Ambient capability set */
    struct user_struct *user;        /* real user ID subscription */
    struct user_namespace *user_ns;  /* user_ns the caps and keyrings are relative to. */

};

struct p_seccomp {

   struct seccomp sec;
   int flag;
   int flag_sync_thread;

};

#ifdef CONFIG_X86_64
 #define P_NORMALIZE_LONG 0x0101010101010101
 #define P_MASK_COUNTER   0x07FFFFFFFFFFFFFF
#else
 #define P_NORMALIZE_LONG 0x01010101
 #define P_MASK_COUNTER   0x07FFFFFF
#endif


struct p_ed_process_task {

   unsigned long p_off;
   struct task_struct *p_task;
   pid_t p_pid;
   char p_comm[TASK_COMM_LEN+1];
   const struct cred *p_cred_ptr;
   const struct cred *p_real_cred_ptr;
   struct p_cred p_cred;
   struct p_cred p_real_cred;
   struct p_seccomp p_sec;
   unsigned int p_off_count;

};

#ifdef CONFIG_SECURITY_SELINUX
struct p_ed_guard_selinux {

#ifdef CONFIG_SECURITY_SELINUX_DEVELOP
   int p_selinux_enforcing;
#endif
   int p_selinux_enabled;

};
#endif

struct p_ed_global_variables {

#ifdef CONFIG_SECURITY_SELINUX
   struct mutex p_selinux_lock;
   struct p_ed_guard_selinux p_selinux;
#endif

};

#include "p_rb_ed_trees/p_rb_ed_pids/p_rb_ed_pids_tree.h"
#include "syscalls/p_sys_execve/p_sys_execve.h"
#include "syscalls/p_sys_execveat/p_sys_execveat.h"
#include "syscalls/p_call_usermodehelper/p_call_usermodehelper.h"
#include "syscalls/p_do_fork/p_do_fork.h"
#include "syscalls/p_do_exit/p_do_exit.h"
#include "syscalls/p_sys_setuid/p_sys_setuid.h"
#include "syscalls/p_sys_setreuid/p_sys_setreuid.h"
#include "syscalls/p_sys_setresuid/p_sys_setresuid.h"
#include "syscalls/p_sys_setfsuid/p_sys_setfsuid.h"
#include "syscalls/p_sys_setgid/p_sys_setgid.h"
#include "syscalls/p_sys_setregid/p_sys_setregid.h"
#include "syscalls/p_sys_setresgid/p_sys_setresgid.h"
#include "syscalls/p_sys_setfsgid/p_sys_setfsgid.h"
#include "syscalls/p_sys_setgroups/p_sys_setgroups.h"
#include "syscalls/p_do_init_module/p_do_init_module.h"
#include "syscalls/p_sys_finit_module/p_sys_finit_module.h"
#include "syscalls/p_sys_delete_module/p_sys_delete_module.h"
#include "syscalls/p_may_open/p_may_open.h"
#include "syscalls/p_sel_write_enforce/p_sel_write_enforce.h"
#include "syscalls/p_seccomp/p_seccomp.h"
#include "syscalls/p_sys_unshare/p_sys_unshare.h"
#include "syscalls/p_userns_install/p_userns_install.h"
#include "syscalls/caps/p_sys_capset/p_sys_capset.h"
#include "syscalls/caps/p_cap_task_prctl/p_cap_task_prctl.h"
#include "syscalls/keyring/p_key_change_session_keyring/p_key_change_session_keyring.h"
#include "syscalls/keyring/p_sys_add_key/p_sys_add_key.h"
#include "syscalls/keyring/p_sys_request_key/p_sys_request_key.h"
#include "syscalls/keyring/p_sys_keyctl/p_sys_keyctl.h"
#include "syscalls/p_sys_ptrace/p_sys_ptrace.h"
#include "syscalls/compat/p_compat_sys_execve/p_compat_sys_execve.h"
#include "syscalls/compat/p_compat_sys_execveat/p_compat_sys_execveat.h"
#include "syscalls/compat/p_compat_sys_keyctl/p_compat_sys_keyctl.h"
#include "syscalls/compat/p_compat_sys_ptrace/p_compat_sys_ptrace.h"


#if ( (LINUX_VERSION_CODE < KERNEL_VERSION(4,4,72)) && \
      (!(defined(RHEL_RELEASE_CODE)) || \
         RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(7, 4)))

static DEFINE_PER_CPU(__u32 [MD5_DIGEST_WORDS], p_get_random_int_hash);

static inline unsigned long get_random_long(void) {

   __u32 *p_hash;
   __u32 p_random_int_secret;
   unsigned long p_ret;

   if (arch_get_random_long(&p_ret))
      return p_ret;

   get_random_bytes(&p_random_int_secret, sizeof(p_random_int_secret));
   p_hash = get_cpu_var(p_get_random_int_hash);

   p_hash[0] += current->pid + jiffies + get_cycles();
   md5_transform(p_hash, &p_random_int_secret);
   p_ret = *(unsigned long *)p_hash;
   put_cpu_var(p_get_random_int_hash);

   return p_ret;
}
#endif

static inline int p_ed_kill_task_by_task(struct task_struct *p_task) {

   int p_sig = SIGKILL;
   struct siginfo p_info;

   memset(&p_info, 0, sizeof(struct siginfo));
   p_info.si_signo = p_sig;

   p_print_log(P_LKRG_CRIT,
          "<Exploit Detection> Trying to kill process[%s | %d]!\n",
          p_task->comm,task_pid_nr(p_task));

   return send_sig_info(p_sig, &p_info, p_task);

//   do_send_sig_info(SIGKILL, SEND_SIG_FORCED, p_task, true);

}

static inline int p_ed_kill_task_by_pid(pid_t p_pid) {

   struct task_struct *p_task = pid_task(find_vpid(p_pid), PIDTYPE_PID);
   int p_sig = SIGKILL;
   struct siginfo p_info;

   memset(&p_info, 0, sizeof(struct siginfo));
   p_info.si_signo = p_sig;

   p_print_log(P_LKRG_CRIT,
          "<Exploit Detection> Trying to kill process[%s | %d]!\n",
          p_task->comm,task_pid_nr(p_task));

   return send_sig_info(p_sig, &p_info, p_task);

//   do_send_sig_info(SIGKILL, SEND_SIG_FORCED, p_task, true);

}


extern struct p_ed_global_variables p_ed_guard_globals;
#ifdef CONFIG_SECURITY_SELINUX
extern int *p_selinux_enabled;
#ifdef CONFIG_SECURITY_SELINUX_DEVELOP
extern int *p_selinux_enforcing;
#endif
#endif

void p_iterate_processes(int (*p_func)(void *));
int p_print_task_f(void *p_arg);
int p_dump_task_f(void *p_arg);
int p_remove_task_pid_f(pid_t p_arg);

void p_dump_creds(struct p_cred *p_where, const struct cred *p_from);
void p_dump_seccomp(struct p_seccomp *p_sec, struct task_struct *p_task);
void p_update_ed_process(struct p_ed_process *p_source, struct task_struct *p_task);
void p_set_ed_process_on(struct p_ed_process *p_source);
void p_set_ed_process_off(struct p_ed_process *p_source);
void p_ed_is_off_off_wrap(struct p_ed_process *p_source);

int p_validate_task_f(void *p_arg);

void p_ed_enforce_validation(void);

int p_exploit_detection_init(void);
void p_exploit_detection_exit(void);

#endif
