/*
 * pi3's Linux kernel Runtime Guard
 *
 * Component:
 *  - Exploit detection main module
 *
 * Notes:
 *  - None
 *
 * Timeline:
 *  - Created: 06.IX.2017
 *
 * Author:
 *  - Adam 'pi3' Zabrocki (http://pi3.com.pl)
 *
 */

#ifndef P_EXPLOIT_DETECTION_MAIN_H
#define P_EXPLOIT_DETECTION_MAIN_H

#ifdef CONFIG_X86_64

 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4,17,0)

  #define P_SYSCALL_LAYOUT_4_17

  /*
   * Linux kernel 4.17.xx introduced some changes which broke LKRG (and not only LKRG).
   * More information about it can be found here:
   *
   * https://lists.gt.net/linux/kernel/2952784
   * https://github.com/torvalds/linux/commit/d5a00528b58cdb2c71206e18bd021e34c4eab878
   *
   * In short, Linux kernel changed the exported names for syscalls (critical change
   * from the LKRG perspective). Currently, one syscall is generating up to 4 stubs
   * (depends on compilation option), e.g. sys_waitid and compat_sys_waitid can be now:
   *
   * 810f2080 T __x64_sys_waitid           # x64 64-bit-ptregs   -> C stub
   * 810f20b0 T __ia32_sys_waitid          # ia32 32-bit-ptregs  -> C stub[*]
   * 810f2470 T __ia32_compat_sys_waitid   # ia32 32-bit-ptregs  -> compat C stub
   * 810f2490 T __x32_compat_sys_waitid    # x32 64-bit-ptregs   -> compat C stub
   *
   *  [*] This stub is often unused - depends on the syscall
   *
   * Example from my Ubuntu VM (kernel 4.17.8) for sys_execve():
   *
   * ffffffffa1a9b9d0 T __ia32_compat_sys_execve
   * ffffffffa1a9ba90 T __ia32_sys_execve [*]
   * ffffffffa1a9bb30 T __x32_compat_sys_execve
   * ffffffffa1a9bb80 T __x64_sys_execve
   *
   *  [*] Unused
   *
   * But at the same time sys_setuid() can be as follow:
   *
   * ffffffffa44a69d0 T __sys_setuid  # NOT a syscall but some of the stubs can wrap it
   * ffffffffa44a6ad0 T __x64_sys_setuid
   * ffffffffa44a6af0 T __ia32_sys_setuid   [*]
   * ffffffffa452b0d0 T __x64_sys_setuid16
   * ffffffffa452b100 T __ia32_sys_setuid16
   *
   *  [*] Used
   *
   * CONFIG_COMPAT / CONFIG_IA32_EMULATION and CONFIG_X86_X32 is covered here.
   *
   */


  #define P_GET_IA32_SYSCALL_NAME(x) P_IA32_SYSCALL_PREFIX(x)
  #define P_GET_IA32_COMPAT_SYSCALL_NAME(x) P_IA32_COMPAT_SYSCALL_PREFIX(x)

  #define P_SYSCALL_PREFIX(x) P_TO_STRING(__x64_sys_ ## x)
  #define P_IA32_SYSCALL_PREFIX(x) P_TO_STRING(__ia32_sys_ ## x)
  #define P_IA32_COMPAT_SYSCALL_PREFIX(x) P_TO_STRING(__ia32_compat_sys_ ## x)
  #define P_GET_SET_ID_PREFIX(x) P_TO_STRING(__sys_ ## x)
  #define P_X32_COMPAT_SYSCALL_PREFIX(x) P_TO_STRING(__x32_compat_sys_ ## x)

  #define P_COMPAT_SYSCALL_PREFIX(x) P_IA32_COMPAT_SYSCALL_PREFIX(x)
  #define P_NEW_COMPAT_SYSCALL_PREFIX(x) P_IA32_SYSCALL_PREFIX(x)

 #else
  #define P_SYSCALL_PREFIX(x) P_TO_STRING(sys_ ## x)
  #define P_COMPAT_SYSCALL_PREFIX(x) P_TO_STRING(compat_sys_ ## x)
  #define P_GET_SET_ID_PREFIX(x) P_SYSCALL_PREFIX(x)
  #define P_X32_COMPAT_SYSCALL_PREFIX
  #define P_NEW_COMPAT_SYSCALL_PREFIX
 #endif
#else
 #define P_SYSCALL_PREFIX(x) P_TO_STRING(sys_ ## x)
 #define P_COMPAT_SYSCALL_PREFIX(x) P_TO_STRING(compat_sys_ ## x)
 #define P_GET_SET_ID_PREFIX(x) P_SYSCALL_PREFIX(x)
 #define P_X32_COMPAT_SYSCALL_PREFIX
 #define P_NEW_COMPAT_SYSCALL_PREFIX
#endif

#define P_TO_STRING(x) # x
#define P_GET_SYSCALL_NAME(x) P_SYSCALL_PREFIX(x)
#define P_GET_COMPAT_SYSCALL_NAME(x) P_COMPAT_SYSCALL_PREFIX(x)
#define P_GET_NEW_COMPAT_SYSCALL_NAME(x) P_NEW_COMPAT_SYSCALL_PREFIX(x)
#define P_GET_SET_ID_NAME(x) P_GET_SET_ID_PREFIX(x)
#define P_GET_X32_SYSCALL_NAME(x) P_X32_COMPAT_SYSCALL_PREFIX(x)

#define P_ED_PROCESS_OFF_MAX 0x1000

#define p_ed_alloc_valid()      kmem_cache_alloc(p_ed_wq_valid_cache, GFP_ATOMIC)
#define p_ed_free_valid(name)   kmem_cache_free(p_ed_wq_valid_cache, (void *)(name))


#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,17,0)
/*
 * It's temporary fix - redefine what can't be imported.
 * TODO: Need to research better way of inspecting SELinux variables!
 */
/* Policy capabilities */
enum {
    POLICYDB_CAPABILITY_NETPEER,
    POLICYDB_CAPABILITY_OPENPERM,
    POLICYDB_CAPABILITY_EXTSOCKCLASS,
    POLICYDB_CAPABILITY_ALWAYSNETWORK,
    POLICYDB_CAPABILITY_CGROUPSECLABEL,
    POLICYDB_CAPABILITY_NNP_NOSUID_TRANSITION,
    __POLICYDB_CAPABILITY_MAX
};

struct p_selinux_state {
    bool disabled;
#ifdef CONFIG_SECURITY_SELINUX_DEVELOP
    bool enforcing;
#endif
    bool checkreqprot;
    bool initialized;
    bool policycap[__POLICYDB_CAPABILITY_MAX];
    struct selinux_avc *avc;
    struct selinux_ss *ss;
};
#endif

struct p_cred {

    kuid_t uid;                      /* real UID of the task */
    kgid_t gid;                      /* real GID of the task */
    kuid_t suid;                     /* saved UID of the task */
    kgid_t sgid;                     /* saved GID of the task */
    kuid_t euid;                     /* effective UID of the task */
    kgid_t egid;                     /* effective GID of the task */
    kuid_t fsuid;                    /* UID for VFS ops */
    kgid_t fsgid;                    /* GID for VFS ops */
    unsigned securebits;             /* SUID-less security management */
    kernel_cap_t cap_inheritable;    /* caps our children can inherit */
    kernel_cap_t cap_permitted;      /* caps we're permitted */
    kernel_cap_t cap_effective;      /* caps we can actually use */
    kernel_cap_t cap_bset;           /* capability bounding set */
    kernel_cap_t cap_ambient;        /* Ambient capability set */
    struct user_struct *user;        /* real user ID subscription */
    struct user_namespace *user_ns;  /* user_ns the caps and keyrings are relative to. */

};

struct p_seccomp {

   struct seccomp sec;
   int flag;
   int flag_sync_thread;

};

#ifdef CONFIG_X86_64
 #define P_NORMALIZE_LONG 0x0101010101010101
 #define P_MASK_COUNTER   0x07FFFFFFFFFFFFFF
#else
 #define P_NORMALIZE_LONG 0x01010101
 #define P_MASK_COUNTER   0x07FFFFFF
#endif


struct p_ed_process_task {

   unsigned long p_off;
   struct task_struct *p_task;
   pid_t p_pid;
   char p_comm[TASK_COMM_LEN+1];
   const struct cred *p_cred_ptr;
   const struct cred *p_real_cred_ptr;
   struct p_cred p_cred;
   struct p_cred p_real_cred;
   struct p_seccomp p_sec;
   unsigned int p_off_count;

};

#ifdef CONFIG_SECURITY_SELINUX
struct p_ed_guard_selinux {

#ifdef CONFIG_SECURITY_SELINUX_DEVELOP
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4,17,0)
   struct p_selinux_state p_selinux_state;
 #else
   int p_selinux_enforcing;
 #endif
#endif
   int p_selinux_enabled;

};
#endif

struct p_ed_global_variables {

#ifdef CONFIG_SECURITY_SELINUX
   struct mutex p_selinux_lock;
   struct p_ed_guard_selinux p_selinux;
#endif

};

#include "p_rb_ed_trees/p_rb_ed_pids/p_rb_ed_pids_tree.h"
#include "syscalls/p_sys_execve/p_sys_execve.h"
#include "syscalls/p_sys_execveat/p_sys_execveat.h"
#include "syscalls/p_call_usermodehelper/p_call_usermodehelper.h"
#include "syscalls/p_do_fork/p_do_fork.h"
#include "syscalls/p_do_exit/p_do_exit.h"
#include "syscalls/p_sys_setuid/p_sys_setuid.h"
#include "syscalls/p_sys_setreuid/p_sys_setreuid.h"
#include "syscalls/p_sys_setresuid/p_sys_setresuid.h"
#include "syscalls/p_sys_setfsuid/p_sys_setfsuid.h"
#include "syscalls/p_sys_setgid/p_sys_setgid.h"
#include "syscalls/p_sys_setregid/p_sys_setregid.h"
#include "syscalls/p_sys_setresgid/p_sys_setresgid.h"
#include "syscalls/p_sys_setfsgid/p_sys_setfsgid.h"
#include "syscalls/p_set_current_groups/p_set_current_groups.h"
#include "syscalls/p_do_init_module/p_do_init_module.h"
#include "syscalls/p_sys_finit_module/p_sys_finit_module.h"
#include "syscalls/p_sys_delete_module/p_sys_delete_module.h"
#include "syscalls/p_may_open/p_may_open.h"
#include "syscalls/p_sel_write_enforce/p_sel_write_enforce.h"
#include "syscalls/p_seccomp/p_seccomp.h"
#include "syscalls/p_sys_unshare/p_sys_unshare.h"
#include "syscalls/p_userns_install/p_userns_install.h"
#include "syscalls/caps/p_sys_capset/p_sys_capset.h"
#include "syscalls/caps/p_cap_task_prctl/p_cap_task_prctl.h"
#include "syscalls/keyring/p_key_change_session_keyring/p_key_change_session_keyring.h"
#include "syscalls/keyring/p_sys_add_key/p_sys_add_key.h"
#include "syscalls/keyring/p_sys_request_key/p_sys_request_key.h"
#include "syscalls/keyring/p_sys_keyctl/p_sys_keyctl.h"
#include "syscalls/p_sys_ptrace/p_sys_ptrace.h"
#include "syscalls/compat/p_compat_sys_execve/p_compat_sys_execve.h"
#include "syscalls/compat/p_compat_sys_execveat/p_compat_sys_execveat.h"
#include "syscalls/compat/p_compat_sys_keyctl/p_compat_sys_keyctl.h"
#include "syscalls/compat/p_compat_sys_ptrace/p_compat_sys_ptrace.h"
#include "syscalls/compat/p_compat_sys_delete_module/p_compat_sys_delete_module.h"
#include "syscalls/compat/p_compat_sys_capset/p_compat_sys_capset.h"
#include "syscalls/compat/p_compat_sys_add_key/p_compat_sys_add_key.h"
#include "syscalls/compat/p_compat_sys_request_key/p_compat_sys_request_key.h"
#include "syscalls/__x32/p_x32_sys_execve/p_x32_sys_execve.h"
#include "syscalls/__x32/p_x32_sys_execveat/p_x32_sys_execveat.h"
#include "syscalls/__x32/p_x32_sys_keyctl/p_x32_sys_keyctl.h"
#include "syscalls/__x32/p_x32_sys_ptrace/p_x32_sys_ptrace.h"


#if ( (LINUX_VERSION_CODE < KERNEL_VERSION(4,4,72)) && \
      (!(defined(RHEL_RELEASE_CODE)) || \
         RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(7, 4)))

static DEFINE_PER_CPU(__u32 [MD5_DIGEST_WORDS], p_get_random_int_hash);

static inline unsigned long get_random_long(void) {

   __u32 *p_hash;
   __u32 p_random_int_secret;
   unsigned long p_ret;

   if (arch_get_random_long(&p_ret))
      return p_ret;

   get_random_bytes(&p_random_int_secret, sizeof(p_random_int_secret));
   p_hash = get_cpu_var(p_get_random_int_hash);

   p_hash[0] += current->pid + jiffies + get_cycles();
   md5_transform(p_hash, &p_random_int_secret);
   p_ret = *(unsigned long *)p_hash;
   put_cpu_var(p_get_random_int_hash);

   return p_ret;
}
#endif

static inline int p_ed_kill_task_by_task(struct task_struct *p_task) {

   int p_sig = SIGKILL;
   struct siginfo p_info;

   memset(&p_info, 0, sizeof(struct siginfo));
   p_info.si_signo = p_sig;

   p_print_log(P_LKRG_CRIT,
          "<Exploit Detection> Trying to kill process[%s | %d]!\n",
          p_task->comm,task_pid_nr(p_task));

   return send_sig_info(p_sig, &p_info, p_task);

//   do_send_sig_info(SIGKILL, SEND_SIG_FORCED, p_task, true);

}

static inline int p_ed_kill_task_by_pid(pid_t p_pid) {

   struct task_struct *p_task = pid_task(find_vpid(p_pid), PIDTYPE_PID);
   int p_sig = SIGKILL;
   struct siginfo p_info;

   memset(&p_info, 0, sizeof(struct siginfo));
   p_info.si_signo = p_sig;

   p_print_log(P_LKRG_CRIT,
          "<Exploit Detection> Trying to kill process[%s | %d]!\n",
          p_task->comm,task_pid_nr(p_task));

   return send_sig_info(p_sig, &p_info, p_task);

//   do_send_sig_info(SIGKILL, SEND_SIG_FORCED, p_task, true);

}


extern struct p_ed_global_variables p_ed_guard_globals;
#ifdef CONFIG_SECURITY_SELINUX
extern int *p_selinux_enabled;
#ifdef CONFIG_SECURITY_SELINUX_DEVELOP
#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,17,0)
extern struct p_selinux_state *p_selinux_state;
#else
extern int *p_selinux_enforcing;
#endif
#endif
#endif

void p_iterate_processes(int (*p_func)(void *));
int p_print_task_f(void *p_arg);
int p_dump_task_f(void *p_arg);
int p_remove_task_pid_f(pid_t p_arg);

void p_dump_creds(struct p_cred *p_where, const struct cred *p_from);
void p_dump_seccomp(struct p_seccomp *p_sec, struct task_struct *p_task);
void p_update_ed_process(struct p_ed_process *p_source, struct task_struct *p_task);
void p_set_ed_process_on(struct p_ed_process *p_source);
void p_set_ed_process_off(struct p_ed_process *p_source);
void p_ed_is_off_off_wrap(struct p_ed_process *p_source);

int p_validate_task_f(void *p_arg);

void p_ed_enforce_validation(void);

int p_exploit_detection_init(void);
void p_exploit_detection_exit(void);

#endif
