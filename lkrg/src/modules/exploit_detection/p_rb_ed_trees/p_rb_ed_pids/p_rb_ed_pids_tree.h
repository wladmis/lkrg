/*
 * pi3's Linux kernel Runtime Guard
 *
 * Component:
 *  - Red-black tree for keeping track user-mode process pid structure
 *
 * Notes:
 *  - Make sence with own kmem_cache_* allocation
 *
 * Timeline:
 *  - Created: 07.IX.2017
 *
 * Author:
 *  - Adam 'pi3' Zabrocki (http://pi3.com.pl)
 *
 */

#ifndef P_LKRG_EXPLOIT_DETECTION_RB_TREE_H
#define P_LKRG_EXPLOIT_DETECTION_RB_TREE_H

#define p_alloc_ed_pids()      kmem_cache_alloc(p_ed_pids_cache, GFP_ATOMIC)
#define p_free_ed_pids(name)   kmem_cache_free(p_ed_pids_cache, (void *)(name))

//#ifdef P_LKRG_DEBUG
#define P_DUMP_RB_ED_PIDS_TREE                                                                        \
do {                                                                                                  \
   struct rb_node *p_node;                                                                            \
                                                                                                      \
   for (p_node = rb_first(&p_global_ed_pids_root); p_node; p_node = rb_next(p_node))                  \
     /* p_debug_log(P_LKRG_DBG, */                                                                    \
        p_print_log(P_LKRG_CRIT,   "<%s> pid[%d] [uid[%d] gid[%d] ruid[%d] rgid[%d]\n",               \
                 rb_entry(p_node, struct p_ed_process, p_rb)->p_ed_task.p_comm,                       \
                 rb_entry(p_node, struct p_ed_process, p_rb)->p_ed_task.p_pid,                        \
                 p_get_uid(&rb_entry(p_node, struct p_ed_process, p_rb)->p_ed_task.p_cred.uid),       \
                 p_get_gid(&rb_entry(p_node, struct p_ed_process, p_rb)->p_ed_task.p_cred.gid),       \
                 p_get_uid(&rb_entry(p_node, struct p_ed_process, p_rb)->p_ed_task.p_real_cred.uid),  \
                 p_get_gid(&rb_entry(p_node, struct p_ed_process, p_rb)->p_ed_task.p_real_cred.gid)   \
                 );                                                                                   \
} while(0);
//#endif


struct p_ed_process {

   struct rb_node p_rb;
   struct p_ed_process_task p_ed_task;
   /* ... add other driver-specific fields */

};

extern struct kmem_cache *p_ed_pids_cache;
extern struct rb_root p_global_ed_pids_root;
extern spinlock_t p_rb_ed_pids_lock;


static inline void p_rb_init_ed_pid_node(struct rb_node *rb) {

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Entering function <p_rb_init_ed_pid_node>\n");

   rb->__rb_parent_color = 0;
   rb->rb_right = NULL;
   rb->rb_left = NULL;
   RB_CLEAR_NODE(rb);

// STRONG_DEBUG
   p_debug_log(P_LKRG_STRONG_DBG,
          "Leaving function <p_rb_init_ed_pid_node>\n");
}

struct p_ed_process *p_rb_find_ed_pid(struct rb_root *p_root, pid_t p_arg);
struct p_ed_process *p_rb_add_ed_pid(struct rb_root *p_root, pid_t p_arg, struct p_ed_process *p_source);
void p_rb_del_ed_pid(struct rb_root *p_root, struct p_ed_process *p_source);
int p_init_rb_ed_pids(void);
void p_delete_rb_ed_pids(void);

#endif
